// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vehicle-commands.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Proto_Door: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// the lowercase versions are for json (de)serialization purposes only. The upper case version should be the preferred
  /// enum values to be used in code.
  /// These definitions need to come before upper case versions
  case unknownDoor // = 0
  case frontleft // = 1
  case frontright // = 2
  case rearleft // = 3
  case rearright // = 4
  case trunk // = 5
  case fuelflap // = 6
  case chargeflap // = 7
  case chargecoupler // = 8
  static let frontLeft = frontleft
  static let frontRight = frontright
  static let rearLeft = rearleft
  static let rearRight = rearright
  static let fuelFlap = fuelflap
  static let chargeFlap = chargeflap
  static let chargeCoupler = chargecoupler
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownDoor
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDoor
    case 1: self = .frontleft
    case 2: self = .frontright
    case 3: self = .rearleft
    case 4: self = .rearright
    case 5: self = .trunk
    case 6: self = .fuelflap
    case 7: self = .chargeflap
    case 8: self = .chargecoupler
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownDoor: return 0
    case .frontleft: return 1
    case .frontright: return 2
    case .rearleft: return 3
    case .rearright: return 4
    case .trunk: return 5
    case .fuelflap: return 6
    case .chargeflap: return 7
    case .chargecoupler: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Door: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_Door] = [
    .unknownDoor,
    .frontleft,
    .frontright,
    .rearleft,
    .rearright,
    .trunk,
    .fuelflap,
    .chargeflap,
    .chargecoupler,
  ]
}

#endif  // swift(>=4.2)

enum Proto_ZEVPreconditioningType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// the lowercase versions are for json parsing purposes only. The upper case version should be the preferred
  /// enum values to be used in code.
  /// These definitions need to come before upper case versions
  case unknownZevPreconditioningCommandType // = 0
  case immediate // = 1
  case departure // = 2
  case now // = 3
  case departureWeekly // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownZevPreconditioningCommandType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownZevPreconditioningCommandType
    case 1: self = .immediate
    case 2: self = .departure
    case 3: self = .now
    case 4: self = .departureWeekly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownZevPreconditioningCommandType: return 0
    case .immediate: return 1
    case .departure: return 2
    case .now: return 3
    case .departureWeekly: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_ZEVPreconditioningType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ZEVPreconditioningType] = [
    .unknownZevPreconditioningCommandType,
    .immediate,
    .departure,
    .now,
    .departureWeekly,
  ]
}

#endif  // swift(>=4.2)

/// Part of a CommandStatusUpdate
/// Sending direction: App <- BFF <- AppTwin
struct Proto_CommandStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The remote VVA process id of the command.
  var processID: Int64 {
    get {return _storage._processID}
    set {_uniqueStorage()._processID = newValue}
  }

  /// The id of the command with which the app created it. Only set on the first transmission to the app.
  var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// The initial CommandStatus from the response of the VVA has a timestamp of -1
  var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  /// The initial CommandStatus from the response of the VVA has a timestamp of -1
  var timestampInMs: Int64 {
    get {return _storage._timestampInMs}
    set {_uniqueStorage()._timestampInMs = newValue}
  }

  /// Potential ACP error if the command request could not be fulfilled
  var errors: [Proto_CommandStatus.AcpError] {
    get {return _storage._errors}
    set {_uniqueStorage()._errors = newValue}
  }

  /// Potential timestamp until user cannot send login/pin requests. Data in seconds since Unix epoch
  var blockingTimeSeconds: Int64 {
    get {return _storage._blockingTimeSeconds}
    set {_uniqueStorage()._blockingTimeSeconds = newValue}
  }

  /// Potential amount of failed pin attempts.
  var pinAttempts: Int32 {
    get {return _storage._pinAttempts}
    set {_uniqueStorage()._pinAttempts = newValue}
  }

  /// The type of command the CommandStatus belongs to. Not guaranteed to be always set.
  var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var auxheatStart: Proto_AuxheatStart {
    get {
      if case .auxheatStart(let v)? = _storage._type {return v}
      return Proto_AuxheatStart()
    }
    set {_uniqueStorage()._type = .auxheatStart(newValue)}
  }

  var auxheatStop: Proto_AuxheatStop {
    get {
      if case .auxheatStop(let v)? = _storage._type {return v}
      return Proto_AuxheatStop()
    }
    set {_uniqueStorage()._type = .auxheatStop(newValue)}
  }

  var auxheatConfigure: Proto_AuxheatConfigure {
    get {
      if case .auxheatConfigure(let v)? = _storage._type {return v}
      return Proto_AuxheatConfigure()
    }
    set {_uniqueStorage()._type = .auxheatConfigure(newValue)}
  }

  var doorsLock: Proto_DoorsLock {
    get {
      if case .doorsLock(let v)? = _storage._type {return v}
      return Proto_DoorsLock()
    }
    set {_uniqueStorage()._type = .doorsLock(newValue)}
  }

  var doorsUnlock: Proto_DoorsUnlock {
    get {
      if case .doorsUnlock(let v)? = _storage._type {return v}
      return Proto_DoorsUnlock()
    }
    set {_uniqueStorage()._type = .doorsUnlock(newValue)}
  }

  var sunroofOpen: Proto_SunroofOpen {
    get {
      if case .sunroofOpen(let v)? = _storage._type {return v}
      return Proto_SunroofOpen()
    }
    set {_uniqueStorage()._type = .sunroofOpen(newValue)}
  }

  var sunroofClose: Proto_SunroofClose {
    get {
      if case .sunroofClose(let v)? = _storage._type {return v}
      return Proto_SunroofClose()
    }
    set {_uniqueStorage()._type = .sunroofClose(newValue)}
  }

  var sunroofLift: Proto_SunroofLift {
    get {
      if case .sunroofLift(let v)? = _storage._type {return v}
      return Proto_SunroofLift()
    }
    set {_uniqueStorage()._type = .sunroofLift(newValue)}
  }

  var windowsOpen: Proto_WindowsOpen {
    get {
      if case .windowsOpen(let v)? = _storage._type {return v}
      return Proto_WindowsOpen()
    }
    set {_uniqueStorage()._type = .windowsOpen(newValue)}
  }

  var windowsClose: Proto_WindowsClose {
    get {
      if case .windowsClose(let v)? = _storage._type {return v}
      return Proto_WindowsClose()
    }
    set {_uniqueStorage()._type = .windowsClose(newValue)}
  }

  var engineStart: Proto_EngineStart {
    get {
      if case .engineStart(let v)? = _storage._type {return v}
      return Proto_EngineStart()
    }
    set {_uniqueStorage()._type = .engineStart(newValue)}
  }

  var engineStop: Proto_EngineStop {
    get {
      if case .engineStop(let v)? = _storage._type {return v}
      return Proto_EngineStop()
    }
    set {_uniqueStorage()._type = .engineStop(newValue)}
  }

  var state: Proto_CommandStatus.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var condition: Proto_CommandStatus.Condition {
    get {return _storage._condition}
    set {_uniqueStorage()._condition = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of command the CommandStatus belongs to. Not guaranteed to be always set.
  enum OneOf_Type: Equatable {
    case auxheatStart(Proto_AuxheatStart)
    case auxheatStop(Proto_AuxheatStop)
    case auxheatConfigure(Proto_AuxheatConfigure)
    case doorsLock(Proto_DoorsLock)
    case doorsUnlock(Proto_DoorsUnlock)
    case sunroofOpen(Proto_SunroofOpen)
    case sunroofClose(Proto_SunroofClose)
    case sunroofLift(Proto_SunroofLift)
    case windowsOpen(Proto_WindowsOpen)
    case windowsClose(Proto_WindowsClose)
    case engineStart(Proto_EngineStart)
    case engineStop(Proto_EngineStop)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_CommandStatus.OneOf_Type, rhs: Proto_CommandStatus.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.auxheatStart(let l), .auxheatStart(let r)): return l == r
      case (.auxheatStop(let l), .auxheatStop(let r)): return l == r
      case (.auxheatConfigure(let l), .auxheatConfigure(let r)): return l == r
      case (.doorsLock(let l), .doorsLock(let r)): return l == r
      case (.doorsUnlock(let l), .doorsUnlock(let r)): return l == r
      case (.sunroofOpen(let l), .sunroofOpen(let r)): return l == r
      case (.sunroofClose(let l), .sunroofClose(let r)): return l == r
      case (.sunroofLift(let l), .sunroofLift(let r)): return l == r
      case (.windowsOpen(let l), .windowsOpen(let r)): return l == r
      case (.windowsClose(let l), .windowsClose(let r)): return l == r
      case (.engineStart(let l), .engineStart(let r)): return l == r
      case (.engineStop(let l), .engineStop(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  enum AcpError: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownAcpError // = 0
    case valueOutOfRange // = 1
    case wrongDataType // = 2
    case valueOverflow // = 3
    case incompleteValues // = 4
    case syntaxError // = 5
    case nullInfValues // = 6
    case lockFailed // = 7
    case failedDueToDoorIsOpen // = 8
    case failedDueToIgnitionIsOn // = 9
    case lockRequestNotAuthorized // = 10
    case unlockFailed // = 11
    case failedDueToTimeout // = 12
    case failedDueToInvalidSmsTime // = 13
    case failedBecauseVehicleIsInMotion // = 14
    case failedDueToIgnitionTransition // = 15
    case unlockRequestNotAuthorized // = 16
    case doorIsOpenAfterUnlockCommand // = 17
    case processingFailed // = 18
    case serviceNotAuthorized // = 19
    case remoteWindowRoofCommandFailed // = 20
    case remoteWindowRoofCommandFailedVehicleStateInIgn // = 21
    case remoteWindowRoofCommandFailedWindowNotNormed // = 22
    case remoteWindowRoofCommandFailedServiceNotAuthorizedInTcu // = 62

    /// The user entered the wrong pin
    case pinInvalid // = 23

    /// There were too many failed pin attempts for this CiamId -> the user can only another try after blockingTime is expired.
    case ciamIDBlocked // = 24
    case rsAbortedDoorsNotLocked // = 27
    case rsAbortedDoorsOpen // = 28
    case rsAbortedHoodOpen // = 29
    case rsAbortedAlarmActive // = 30
    case rsAbortedFuelLow // = 31
    case rsAbortedGasPedalPressed // = 32
    case rsAbortedNotAllowedByEis // = 33
    case rsAbortedEngineUnexpectedShutOff // = 34
    case rsDeniedNotAllowedByEis // = 35
    case rsDeniedVehicleNotInPark // = 36
    case rsDeniedDoorsNotLocked // = 37
    case rsDeniedDoorsOpen // = 38
    case rsDeniedWindowsOpen // = 39
    case rsDeniedHoodOpen // = 40
    case rsDeniedAlarmActive // = 41
    case rsDeniedFuelLow // = 42
    case rsDeniedGasPedalPressed // = 43
    case rsDeniedDelayNotExpired // = 44
    case rsAbortedInvalidChallengeResponse // = 45
    case rsDeniedNumberOfRequestsExpired // = 46
    case rsAbortedRequestRefusedByEngine // = 47
    case rsNoCanAcknowledgement // = 48
    case rsDeniedNotAuthorized // = 49
    case rsAbortedChargeCablePlugged // = 50
    case rsFbsRespGenerationNotPossibleForVin // = 51
    case rsFbsMaintenance // = 52
    case rsCallbackTimeout // = 53
    case rsFbsGeneralError // = 54
    case rsCurrentlyBlocked // = 55
    case rsDeniedAfterChallengeDoorsNotLocked // = 56
    case rsDeniedAfterChallengeDoorsOpen // = 57
    case rsDeniedAfterChallengeHoodOpen // = 58
    case rsDeniedAfterChallengeAlarmActive // = 59
    case rsDeniedAfterChallengeNotAllowedByEis // = 60
    case energyLevelInBatteryIsTooLow // = 63
    case configurationProcessingFailed // = 65
    case processingFailedCustomerMaxSocBelowVehicleThreshold // = 66
    case configurationNotAuthorized // = 67
    case zevWeekDeptSetProcessingFailed // = 68
    case zevWeekDeptSetNotAuthorized // = 69
    case zevWeekDeptSetProcessingOverwritten // = 70
    case zevWeekDeptSetProcessingNotPossibleDueToInstantCharging // = 71
    case fastpathTimeout // = 72
    case zevChargeProgramNotSupportedByVehicle // = 73

    /// Remote Vehicle Finder
    case sigposFailed // = 74
    case sigposVehicleInIgnition // = 75
    case sigposNotAuthorized // = 76

    /// Vehicle Theft Alarm
    case remoteVtaFailed // = 25
    case remoteVtaServiceNotAuthorized // = 26
    case remoteVtaIgnitionNotLocked // = 77
    case remoteVtaVvrValueNotSet // = 78
    case remoteVtaVvrNotAllowed // = 79

    /// Rising Stars Errors
    case noApptwinConnected // = 61
    case vvaRespondedServiceNotActivated // = 64
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownAcpError
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownAcpError
      case 1: self = .valueOutOfRange
      case 2: self = .wrongDataType
      case 3: self = .valueOverflow
      case 4: self = .incompleteValues
      case 5: self = .syntaxError
      case 6: self = .nullInfValues
      case 7: self = .lockFailed
      case 8: self = .failedDueToDoorIsOpen
      case 9: self = .failedDueToIgnitionIsOn
      case 10: self = .lockRequestNotAuthorized
      case 11: self = .unlockFailed
      case 12: self = .failedDueToTimeout
      case 13: self = .failedDueToInvalidSmsTime
      case 14: self = .failedBecauseVehicleIsInMotion
      case 15: self = .failedDueToIgnitionTransition
      case 16: self = .unlockRequestNotAuthorized
      case 17: self = .doorIsOpenAfterUnlockCommand
      case 18: self = .processingFailed
      case 19: self = .serviceNotAuthorized
      case 20: self = .remoteWindowRoofCommandFailed
      case 21: self = .remoteWindowRoofCommandFailedVehicleStateInIgn
      case 22: self = .remoteWindowRoofCommandFailedWindowNotNormed
      case 23: self = .pinInvalid
      case 24: self = .ciamIDBlocked
      case 25: self = .remoteVtaFailed
      case 26: self = .remoteVtaServiceNotAuthorized
      case 27: self = .rsAbortedDoorsNotLocked
      case 28: self = .rsAbortedDoorsOpen
      case 29: self = .rsAbortedHoodOpen
      case 30: self = .rsAbortedAlarmActive
      case 31: self = .rsAbortedFuelLow
      case 32: self = .rsAbortedGasPedalPressed
      case 33: self = .rsAbortedNotAllowedByEis
      case 34: self = .rsAbortedEngineUnexpectedShutOff
      case 35: self = .rsDeniedNotAllowedByEis
      case 36: self = .rsDeniedVehicleNotInPark
      case 37: self = .rsDeniedDoorsNotLocked
      case 38: self = .rsDeniedDoorsOpen
      case 39: self = .rsDeniedWindowsOpen
      case 40: self = .rsDeniedHoodOpen
      case 41: self = .rsDeniedAlarmActive
      case 42: self = .rsDeniedFuelLow
      case 43: self = .rsDeniedGasPedalPressed
      case 44: self = .rsDeniedDelayNotExpired
      case 45: self = .rsAbortedInvalidChallengeResponse
      case 46: self = .rsDeniedNumberOfRequestsExpired
      case 47: self = .rsAbortedRequestRefusedByEngine
      case 48: self = .rsNoCanAcknowledgement
      case 49: self = .rsDeniedNotAuthorized
      case 50: self = .rsAbortedChargeCablePlugged
      case 51: self = .rsFbsRespGenerationNotPossibleForVin
      case 52: self = .rsFbsMaintenance
      case 53: self = .rsCallbackTimeout
      case 54: self = .rsFbsGeneralError
      case 55: self = .rsCurrentlyBlocked
      case 56: self = .rsDeniedAfterChallengeDoorsNotLocked
      case 57: self = .rsDeniedAfterChallengeDoorsOpen
      case 58: self = .rsDeniedAfterChallengeHoodOpen
      case 59: self = .rsDeniedAfterChallengeAlarmActive
      case 60: self = .rsDeniedAfterChallengeNotAllowedByEis
      case 61: self = .noApptwinConnected
      case 62: self = .remoteWindowRoofCommandFailedServiceNotAuthorizedInTcu
      case 63: self = .energyLevelInBatteryIsTooLow
      case 64: self = .vvaRespondedServiceNotActivated
      case 65: self = .configurationProcessingFailed
      case 66: self = .processingFailedCustomerMaxSocBelowVehicleThreshold
      case 67: self = .configurationNotAuthorized
      case 68: self = .zevWeekDeptSetProcessingFailed
      case 69: self = .zevWeekDeptSetNotAuthorized
      case 70: self = .zevWeekDeptSetProcessingOverwritten
      case 71: self = .zevWeekDeptSetProcessingNotPossibleDueToInstantCharging
      case 72: self = .fastpathTimeout
      case 73: self = .zevChargeProgramNotSupportedByVehicle
      case 74: self = .sigposFailed
      case 75: self = .sigposVehicleInIgnition
      case 76: self = .sigposNotAuthorized
      case 77: self = .remoteVtaIgnitionNotLocked
      case 78: self = .remoteVtaVvrValueNotSet
      case 79: self = .remoteVtaVvrNotAllowed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownAcpError: return 0
      case .valueOutOfRange: return 1
      case .wrongDataType: return 2
      case .valueOverflow: return 3
      case .incompleteValues: return 4
      case .syntaxError: return 5
      case .nullInfValues: return 6
      case .lockFailed: return 7
      case .failedDueToDoorIsOpen: return 8
      case .failedDueToIgnitionIsOn: return 9
      case .lockRequestNotAuthorized: return 10
      case .unlockFailed: return 11
      case .failedDueToTimeout: return 12
      case .failedDueToInvalidSmsTime: return 13
      case .failedBecauseVehicleIsInMotion: return 14
      case .failedDueToIgnitionTransition: return 15
      case .unlockRequestNotAuthorized: return 16
      case .doorIsOpenAfterUnlockCommand: return 17
      case .processingFailed: return 18
      case .serviceNotAuthorized: return 19
      case .remoteWindowRoofCommandFailed: return 20
      case .remoteWindowRoofCommandFailedVehicleStateInIgn: return 21
      case .remoteWindowRoofCommandFailedWindowNotNormed: return 22
      case .pinInvalid: return 23
      case .ciamIDBlocked: return 24
      case .remoteVtaFailed: return 25
      case .remoteVtaServiceNotAuthorized: return 26
      case .rsAbortedDoorsNotLocked: return 27
      case .rsAbortedDoorsOpen: return 28
      case .rsAbortedHoodOpen: return 29
      case .rsAbortedAlarmActive: return 30
      case .rsAbortedFuelLow: return 31
      case .rsAbortedGasPedalPressed: return 32
      case .rsAbortedNotAllowedByEis: return 33
      case .rsAbortedEngineUnexpectedShutOff: return 34
      case .rsDeniedNotAllowedByEis: return 35
      case .rsDeniedVehicleNotInPark: return 36
      case .rsDeniedDoorsNotLocked: return 37
      case .rsDeniedDoorsOpen: return 38
      case .rsDeniedWindowsOpen: return 39
      case .rsDeniedHoodOpen: return 40
      case .rsDeniedAlarmActive: return 41
      case .rsDeniedFuelLow: return 42
      case .rsDeniedGasPedalPressed: return 43
      case .rsDeniedDelayNotExpired: return 44
      case .rsAbortedInvalidChallengeResponse: return 45
      case .rsDeniedNumberOfRequestsExpired: return 46
      case .rsAbortedRequestRefusedByEngine: return 47
      case .rsNoCanAcknowledgement: return 48
      case .rsDeniedNotAuthorized: return 49
      case .rsAbortedChargeCablePlugged: return 50
      case .rsFbsRespGenerationNotPossibleForVin: return 51
      case .rsFbsMaintenance: return 52
      case .rsCallbackTimeout: return 53
      case .rsFbsGeneralError: return 54
      case .rsCurrentlyBlocked: return 55
      case .rsDeniedAfterChallengeDoorsNotLocked: return 56
      case .rsDeniedAfterChallengeDoorsOpen: return 57
      case .rsDeniedAfterChallengeHoodOpen: return 58
      case .rsDeniedAfterChallengeAlarmActive: return 59
      case .rsDeniedAfterChallengeNotAllowedByEis: return 60
      case .noApptwinConnected: return 61
      case .remoteWindowRoofCommandFailedServiceNotAuthorizedInTcu: return 62
      case .energyLevelInBatteryIsTooLow: return 63
      case .vvaRespondedServiceNotActivated: return 64
      case .configurationProcessingFailed: return 65
      case .processingFailedCustomerMaxSocBelowVehicleThreshold: return 66
      case .configurationNotAuthorized: return 67
      case .zevWeekDeptSetProcessingFailed: return 68
      case .zevWeekDeptSetNotAuthorized: return 69
      case .zevWeekDeptSetProcessingOverwritten: return 70
      case .zevWeekDeptSetProcessingNotPossibleDueToInstantCharging: return 71
      case .fastpathTimeout: return 72
      case .zevChargeProgramNotSupportedByVehicle: return 73
      case .sigposFailed: return 74
      case .sigposVehicleInIgnition: return 75
      case .sigposNotAuthorized: return 76
      case .remoteVtaIgnitionNotLocked: return 77
      case .remoteVtaVvrValueNotSet: return 78
      case .remoteVtaVvrNotAllowed: return 79
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum State: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unkownStateType // = 0
    case created // = 1
    case enqueued // = 2
    case processing // = 3
    case suspended // = 4
    case finished // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unkownStateType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unkownStateType
      case 1: self = .created
      case 2: self = .enqueued
      case 3: self = .processing
      case 4: self = .suspended
      case 5: self = .finished
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unkownStateType: return 0
      case .created: return 1
      case .enqueued: return 2
      case .processing: return 3
      case .suspended: return 4
      case .finished: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum Condition: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unkownConditionType // = 0
    case none // = 1
    case accepted // = 2
    case rejected // = 3
    case terminate // = 4
    case success // = 5
    case failed // = 6
    case overwritten // = 7
    case timeout // = 8

    /// Not from DaiVB
    case duplicate // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .unkownConditionType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unkownConditionType
      case 1: self = .none
      case 2: self = .accepted
      case 3: self = .rejected
      case 4: self = .terminate
      case 5: self = .success
      case 6: self = .failed
      case 7: self = .overwritten
      case 8: self = .timeout
      case 9: self = .duplicate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unkownConditionType: return 0
      case .none: return 1
      case .accepted: return 2
      case .rejected: return 3
      case .terminate: return 4
      case .success: return 5
      case .failed: return 6
      case .overwritten: return 7
      case .timeout: return 8
      case .duplicate: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Proto_CommandStatus.AcpError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_CommandStatus.AcpError] = [
    .unknownAcpError,
    .valueOutOfRange,
    .wrongDataType,
    .valueOverflow,
    .incompleteValues,
    .syntaxError,
    .nullInfValues,
    .lockFailed,
    .failedDueToDoorIsOpen,
    .failedDueToIgnitionIsOn,
    .lockRequestNotAuthorized,
    .unlockFailed,
    .failedDueToTimeout,
    .failedDueToInvalidSmsTime,
    .failedBecauseVehicleIsInMotion,
    .failedDueToIgnitionTransition,
    .unlockRequestNotAuthorized,
    .doorIsOpenAfterUnlockCommand,
    .processingFailed,
    .serviceNotAuthorized,
    .remoteWindowRoofCommandFailed,
    .remoteWindowRoofCommandFailedVehicleStateInIgn,
    .remoteWindowRoofCommandFailedWindowNotNormed,
    .remoteWindowRoofCommandFailedServiceNotAuthorizedInTcu,
    .pinInvalid,
    .ciamIDBlocked,
    .rsAbortedDoorsNotLocked,
    .rsAbortedDoorsOpen,
    .rsAbortedHoodOpen,
    .rsAbortedAlarmActive,
    .rsAbortedFuelLow,
    .rsAbortedGasPedalPressed,
    .rsAbortedNotAllowedByEis,
    .rsAbortedEngineUnexpectedShutOff,
    .rsDeniedNotAllowedByEis,
    .rsDeniedVehicleNotInPark,
    .rsDeniedDoorsNotLocked,
    .rsDeniedDoorsOpen,
    .rsDeniedWindowsOpen,
    .rsDeniedHoodOpen,
    .rsDeniedAlarmActive,
    .rsDeniedFuelLow,
    .rsDeniedGasPedalPressed,
    .rsDeniedDelayNotExpired,
    .rsAbortedInvalidChallengeResponse,
    .rsDeniedNumberOfRequestsExpired,
    .rsAbortedRequestRefusedByEngine,
    .rsNoCanAcknowledgement,
    .rsDeniedNotAuthorized,
    .rsAbortedChargeCablePlugged,
    .rsFbsRespGenerationNotPossibleForVin,
    .rsFbsMaintenance,
    .rsCallbackTimeout,
    .rsFbsGeneralError,
    .rsCurrentlyBlocked,
    .rsDeniedAfterChallengeDoorsNotLocked,
    .rsDeniedAfterChallengeDoorsOpen,
    .rsDeniedAfterChallengeHoodOpen,
    .rsDeniedAfterChallengeAlarmActive,
    .rsDeniedAfterChallengeNotAllowedByEis,
    .energyLevelInBatteryIsTooLow,
    .configurationProcessingFailed,
    .processingFailedCustomerMaxSocBelowVehicleThreshold,
    .configurationNotAuthorized,
    .zevWeekDeptSetProcessingFailed,
    .zevWeekDeptSetNotAuthorized,
    .zevWeekDeptSetProcessingOverwritten,
    .zevWeekDeptSetProcessingNotPossibleDueToInstantCharging,
    .fastpathTimeout,
    .zevChargeProgramNotSupportedByVehicle,
    .sigposFailed,
    .sigposVehicleInIgnition,
    .sigposNotAuthorized,
    .remoteVtaFailed,
    .remoteVtaServiceNotAuthorized,
    .remoteVtaIgnitionNotLocked,
    .remoteVtaVvrValueNotSet,
    .remoteVtaVvrNotAllowed,
    .noApptwinConnected,
    .vvaRespondedServiceNotActivated,
  ]
}

extension Proto_CommandStatus.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_CommandStatus.State] = [
    .unkownStateType,
    .created,
    .enqueued,
    .processing,
    .suspended,
    .finished,
  ]
}

extension Proto_CommandStatus.Condition: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_CommandStatus.Condition] = [
    .unkownConditionType,
    .none,
    .accepted,
    .rejected,
    .terminate,
    .success,
    .failed,
    .overwritten,
    .timeout,
    .duplicate,
  ]
}

#endif  // swift(>=4.2)

/// acknowledge that the CommandStatusUpdate-Messages of up to `sequence_number` have been received
/// Sending direction: App -> BFF -> AppTwin
struct Proto_AcknowledgeCommandStatusUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Sending direction: App <- BFF <- AppTwin
struct Proto_CommandStatusUpdatesByVIN {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updates: Dictionary<String,Proto_CommandStatusUpdate> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Sending direction: App <- BFF <- AppTwin
struct Proto_CommandStatusUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Int32 = 0

  var vin: String = String()

  /// when was the event emitted? This is the time of the update, (seconds in Unix time) (deprecated)
  /// not when the attributes where changed. To compare attribute changes, you need to look into each attribute timestamp
  var emitTimestamp: Int64 = 0

  /// When was the event emitted (milliseconds in Unix time)
  var emitTimestampInMs: Int64 = 0

  var updates: Dictionary<Int64,Proto_CommandStatus> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Acknowledge the CommandRequest reached the apptwin actor
/// Websocket <- Apptwin
struct Proto_AcknowledgeCommandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// After the command was issued at VVA based on this
/// command request the call will get a command request
/// correlation message which matches the request id
/// with the process id.
/// Sending direction: App - BFF -> AppTwin
struct Proto_CommandRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vin: String {
    get {return _storage._vin}
    set {_uniqueStorage()._vin = newValue}
  }

  /// Set this id to correlate a CommandStatus
  /// with this command request.
  var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  var backend: Proto_CommandRequest.Backend {
    get {return _storage._backend}
    set {_uniqueStorage()._backend = newValue}
  }

  var command: OneOf_Command? {
    get {return _storage._command}
    set {_uniqueStorage()._command = newValue}
  }

  var auxheatStart: Proto_AuxheatStart {
    get {
      if case .auxheatStart(let v)? = _storage._command {return v}
      return Proto_AuxheatStart()
    }
    set {_uniqueStorage()._command = .auxheatStart(newValue)}
  }

  var auxheatStop: Proto_AuxheatStop {
    get {
      if case .auxheatStop(let v)? = _storage._command {return v}
      return Proto_AuxheatStop()
    }
    set {_uniqueStorage()._command = .auxheatStop(newValue)}
  }

  var auxheatConfigure: Proto_AuxheatConfigure {
    get {
      if case .auxheatConfigure(let v)? = _storage._command {return v}
      return Proto_AuxheatConfigure()
    }
    set {_uniqueStorage()._command = .auxheatConfigure(newValue)}
  }

  var doorsLock: Proto_DoorsLock {
    get {
      if case .doorsLock(let v)? = _storage._command {return v}
      return Proto_DoorsLock()
    }
    set {_uniqueStorage()._command = .doorsLock(newValue)}
  }

  var doorsUnlock: Proto_DoorsUnlock {
    get {
      if case .doorsUnlock(let v)? = _storage._command {return v}
      return Proto_DoorsUnlock()
    }
    set {_uniqueStorage()._command = .doorsUnlock(newValue)}
  }

  var sunroofOpen: Proto_SunroofOpen {
    get {
      if case .sunroofOpen(let v)? = _storage._command {return v}
      return Proto_SunroofOpen()
    }
    set {_uniqueStorage()._command = .sunroofOpen(newValue)}
  }

  var sunroofClose: Proto_SunroofClose {
    get {
      if case .sunroofClose(let v)? = _storage._command {return v}
      return Proto_SunroofClose()
    }
    set {_uniqueStorage()._command = .sunroofClose(newValue)}
  }

  var sunroofLift: Proto_SunroofLift {
    get {
      if case .sunroofLift(let v)? = _storage._command {return v}
      return Proto_SunroofLift()
    }
    set {_uniqueStorage()._command = .sunroofLift(newValue)}
  }

  var windowsOpen: Proto_WindowsOpen {
    get {
      if case .windowsOpen(let v)? = _storage._command {return v}
      return Proto_WindowsOpen()
    }
    set {_uniqueStorage()._command = .windowsOpen(newValue)}
  }

  var windowsClose: Proto_WindowsClose {
    get {
      if case .windowsClose(let v)? = _storage._command {return v}
      return Proto_WindowsClose()
    }
    set {_uniqueStorage()._command = .windowsClose(newValue)}
  }

  var engineStart: Proto_EngineStart {
    get {
      if case .engineStart(let v)? = _storage._command {return v}
      return Proto_EngineStart()
    }
    set {_uniqueStorage()._command = .engineStart(newValue)}
  }

  var engineStop: Proto_EngineStop {
    get {
      if case .engineStop(let v)? = _storage._command {return v}
      return Proto_EngineStop()
    }
    set {_uniqueStorage()._command = .engineStop(newValue)}
  }

  var zevPreconditioningStart: Proto_ZEVPreconditioningStart {
    get {
      if case .zevPreconditioningStart(let v)? = _storage._command {return v}
      return Proto_ZEVPreconditioningStart()
    }
    set {_uniqueStorage()._command = .zevPreconditioningStart(newValue)}
  }

  var zevPreconditioningStop: Proto_ZEVPreconditioningStop {
    get {
      if case .zevPreconditioningStop(let v)? = _storage._command {return v}
      return Proto_ZEVPreconditioningStop()
    }
    set {_uniqueStorage()._command = .zevPreconditioningStop(newValue)}
  }

  var zevPreconditionConfigure: Proto_ZEVPreconditioningConfigure {
    get {
      if case .zevPreconditionConfigure(let v)? = _storage._command {return v}
      return Proto_ZEVPreconditioningConfigure()
    }
    set {_uniqueStorage()._command = .zevPreconditionConfigure(newValue)}
  }

  var zevPreconditionConfigureSeats: Proto_ZEVPreconditioningConfigureSeats {
    get {
      if case .zevPreconditionConfigureSeats(let v)? = _storage._command {return v}
      return Proto_ZEVPreconditioningConfigureSeats()
    }
    set {_uniqueStorage()._command = .zevPreconditionConfigureSeats(newValue)}
  }

  var speedalertStart: Proto_SpeedalertStart {
    get {
      if case .speedalertStart(let v)? = _storage._command {return v}
      return Proto_SpeedalertStart()
    }
    set {_uniqueStorage()._command = .speedalertStart(newValue)}
  }

  var speedalertStop: Proto_SpeedalertStop {
    get {
      if case .speedalertStop(let v)? = _storage._command {return v}
      return Proto_SpeedalertStop()
    }
    set {_uniqueStorage()._command = .speedalertStop(newValue)}
  }

  var batteryChargeProgram: Proto_BatteryChargeProgramConfigure {
    get {
      if case .batteryChargeProgram(let v)? = _storage._command {return v}
      return Proto_BatteryChargeProgramConfigure()
    }
    set {_uniqueStorage()._command = .batteryChargeProgram(newValue)}
  }

  var batteryMaxSoc: Proto_BatteryMaxSocConfigure {
    get {
      if case .batteryMaxSoc(let v)? = _storage._command {return v}
      return Proto_BatteryMaxSocConfigure()
    }
    set {_uniqueStorage()._command = .batteryMaxSoc(newValue)}
  }

  var chargeProgramConfigure: Proto_ChargeProgramConfigure {
    get {
      if case .chargeProgramConfigure(let v)? = _storage._command {return v}
      return Proto_ChargeProgramConfigure()
    }
    set {_uniqueStorage()._command = .chargeProgramConfigure(newValue)}
  }

  var chargeOptConfigure: Proto_ChargeOptConfigure {
    get {
      if case .chargeOptConfigure(let v)? = _storage._command {return v}
      return Proto_ChargeOptConfigure()
    }
    set {_uniqueStorage()._command = .chargeOptConfigure(newValue)}
  }

  var chargeOptStart: Proto_ChargeOptStart {
    get {
      if case .chargeOptStart(let v)? = _storage._command {return v}
      return Proto_ChargeOptStart()
    }
    set {_uniqueStorage()._command = .chargeOptStart(newValue)}
  }

  var chargeOptStop: Proto_ChargeOptStop {
    get {
      if case .chargeOptStop(let v)? = _storage._command {return v}
      return Proto_ChargeOptStop()
    }
    set {_uniqueStorage()._command = .chargeOptStop(newValue)}
  }

  var temperatureConfigure: Proto_TemperatureConfigure {
    get {
      if case .temperatureConfigure(let v)? = _storage._command {return v}
      return Proto_TemperatureConfigure()
    }
    set {_uniqueStorage()._command = .temperatureConfigure(newValue)}
  }

  var weekProfileConfigure: Proto_WeekProfileConfigure {
    get {
      if case .weekProfileConfigure(let v)? = _storage._command {return v}
      return Proto_WeekProfileConfigure()
    }
    set {_uniqueStorage()._command = .weekProfileConfigure(newValue)}
  }

  var sigposStart: Proto_SigPosStart {
    get {
      if case .sigposStart(let v)? = _storage._command {return v}
      return Proto_SigPosStart()
    }
    set {_uniqueStorage()._command = .sigposStart(newValue)}
  }

  var theftalarmConfirmDamagedetection: Proto_TheftalarmConfirmDamagedetection {
    get {
      if case .theftalarmConfirmDamagedetection(let v)? = _storage._command {return v}
      return Proto_TheftalarmConfirmDamagedetection()
    }
    set {_uniqueStorage()._command = .theftalarmConfirmDamagedetection(newValue)}
  }

  var theftalarmDeselectDamagedetection: Proto_TheftalarmDeselectDamagedetection {
    get {
      if case .theftalarmDeselectDamagedetection(let v)? = _storage._command {return v}
      return Proto_TheftalarmDeselectDamagedetection()
    }
    set {_uniqueStorage()._command = .theftalarmDeselectDamagedetection(newValue)}
  }

  var theftalarmDeselectInterior: Proto_TheftalarmDeselectInterior {
    get {
      if case .theftalarmDeselectInterior(let v)? = _storage._command {return v}
      return Proto_TheftalarmDeselectInterior()
    }
    set {_uniqueStorage()._command = .theftalarmDeselectInterior(newValue)}
  }

  var theftalarmDeselectTow: Proto_TheftalarmDeselectTow {
    get {
      if case .theftalarmDeselectTow(let v)? = _storage._command {return v}
      return Proto_TheftalarmDeselectTow()
    }
    set {_uniqueStorage()._command = .theftalarmDeselectTow(newValue)}
  }

  var theftalarmSelectDamagedetection: Proto_TheftalarmSelectDamagedetection {
    get {
      if case .theftalarmSelectDamagedetection(let v)? = _storage._command {return v}
      return Proto_TheftalarmSelectDamagedetection()
    }
    set {_uniqueStorage()._command = .theftalarmSelectDamagedetection(newValue)}
  }

  var theftalarmSelectInterior: Proto_TheftalarmSelectInterior {
    get {
      if case .theftalarmSelectInterior(let v)? = _storage._command {return v}
      return Proto_TheftalarmSelectInterior()
    }
    set {_uniqueStorage()._command = .theftalarmSelectInterior(newValue)}
  }

  var theftalarmSelectTow: Proto_TheftalarmSelectTow {
    get {
      if case .theftalarmSelectTow(let v)? = _storage._command {return v}
      return Proto_TheftalarmSelectTow()
    }
    set {_uniqueStorage()._command = .theftalarmSelectTow(newValue)}
  }

  var theftalarmStart: Proto_TheftalarmStart {
    get {
      if case .theftalarmStart(let v)? = _storage._command {return v}
      return Proto_TheftalarmStart()
    }
    set {_uniqueStorage()._command = .theftalarmStart(newValue)}
  }

  var theftalarmStop: Proto_TheftalarmStop {
    get {
      if case .theftalarmStop(let v)? = _storage._command {return v}
      return Proto_TheftalarmStop()
    }
    set {_uniqueStorage()._command = .theftalarmStop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Command: Equatable {
    case auxheatStart(Proto_AuxheatStart)
    case auxheatStop(Proto_AuxheatStop)
    case auxheatConfigure(Proto_AuxheatConfigure)
    case doorsLock(Proto_DoorsLock)
    case doorsUnlock(Proto_DoorsUnlock)
    case sunroofOpen(Proto_SunroofOpen)
    case sunroofClose(Proto_SunroofClose)
    case sunroofLift(Proto_SunroofLift)
    case windowsOpen(Proto_WindowsOpen)
    case windowsClose(Proto_WindowsClose)
    case engineStart(Proto_EngineStart)
    case engineStop(Proto_EngineStop)
    case zevPreconditioningStart(Proto_ZEVPreconditioningStart)
    case zevPreconditioningStop(Proto_ZEVPreconditioningStop)
    case zevPreconditionConfigure(Proto_ZEVPreconditioningConfigure)
    case zevPreconditionConfigureSeats(Proto_ZEVPreconditioningConfigureSeats)
    case speedalertStart(Proto_SpeedalertStart)
    case speedalertStop(Proto_SpeedalertStop)
    case batteryChargeProgram(Proto_BatteryChargeProgramConfigure)
    case batteryMaxSoc(Proto_BatteryMaxSocConfigure)
    case chargeProgramConfigure(Proto_ChargeProgramConfigure)
    case chargeOptConfigure(Proto_ChargeOptConfigure)
    case chargeOptStart(Proto_ChargeOptStart)
    case chargeOptStop(Proto_ChargeOptStop)
    case temperatureConfigure(Proto_TemperatureConfigure)
    case weekProfileConfigure(Proto_WeekProfileConfigure)
    case sigposStart(Proto_SigPosStart)
    case theftalarmConfirmDamagedetection(Proto_TheftalarmConfirmDamagedetection)
    case theftalarmDeselectDamagedetection(Proto_TheftalarmDeselectDamagedetection)
    case theftalarmDeselectInterior(Proto_TheftalarmDeselectInterior)
    case theftalarmDeselectTow(Proto_TheftalarmDeselectTow)
    case theftalarmSelectDamagedetection(Proto_TheftalarmSelectDamagedetection)
    case theftalarmSelectInterior(Proto_TheftalarmSelectInterior)
    case theftalarmSelectTow(Proto_TheftalarmSelectTow)
    case theftalarmStart(Proto_TheftalarmStart)
    case theftalarmStop(Proto_TheftalarmStop)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_CommandRequest.OneOf_Command, rhs: Proto_CommandRequest.OneOf_Command) -> Bool {
      switch (lhs, rhs) {
      case (.auxheatStart(let l), .auxheatStart(let r)): return l == r
      case (.auxheatStop(let l), .auxheatStop(let r)): return l == r
      case (.auxheatConfigure(let l), .auxheatConfigure(let r)): return l == r
      case (.doorsLock(let l), .doorsLock(let r)): return l == r
      case (.doorsUnlock(let l), .doorsUnlock(let r)): return l == r
      case (.sunroofOpen(let l), .sunroofOpen(let r)): return l == r
      case (.sunroofClose(let l), .sunroofClose(let r)): return l == r
      case (.sunroofLift(let l), .sunroofLift(let r)): return l == r
      case (.windowsOpen(let l), .windowsOpen(let r)): return l == r
      case (.windowsClose(let l), .windowsClose(let r)): return l == r
      case (.engineStart(let l), .engineStart(let r)): return l == r
      case (.engineStop(let l), .engineStop(let r)): return l == r
      case (.zevPreconditioningStart(let l), .zevPreconditioningStart(let r)): return l == r
      case (.zevPreconditioningStop(let l), .zevPreconditioningStop(let r)): return l == r
      case (.zevPreconditionConfigure(let l), .zevPreconditionConfigure(let r)): return l == r
      case (.zevPreconditionConfigureSeats(let l), .zevPreconditionConfigureSeats(let r)): return l == r
      case (.speedalertStart(let l), .speedalertStart(let r)): return l == r
      case (.speedalertStop(let l), .speedalertStop(let r)): return l == r
      case (.batteryChargeProgram(let l), .batteryChargeProgram(let r)): return l == r
      case (.batteryMaxSoc(let l), .batteryMaxSoc(let r)): return l == r
      case (.chargeProgramConfigure(let l), .chargeProgramConfigure(let r)): return l == r
      case (.chargeOptConfigure(let l), .chargeOptConfigure(let r)): return l == r
      case (.chargeOptStart(let l), .chargeOptStart(let r)): return l == r
      case (.chargeOptStop(let l), .chargeOptStop(let r)): return l == r
      case (.temperatureConfigure(let l), .temperatureConfigure(let r)): return l == r
      case (.weekProfileConfigure(let l), .weekProfileConfigure(let r)): return l == r
      case (.sigposStart(let l), .sigposStart(let r)): return l == r
      case (.theftalarmConfirmDamagedetection(let l), .theftalarmConfirmDamagedetection(let r)): return l == r
      case (.theftalarmDeselectDamagedetection(let l), .theftalarmDeselectDamagedetection(let r)): return l == r
      case (.theftalarmDeselectInterior(let l), .theftalarmDeselectInterior(let r)): return l == r
      case (.theftalarmDeselectTow(let l), .theftalarmDeselectTow(let r)): return l == r
      case (.theftalarmSelectDamagedetection(let l), .theftalarmSelectDamagedetection(let r)): return l == r
      case (.theftalarmSelectInterior(let l), .theftalarmSelectInterior(let r)): return l == r
      case (.theftalarmSelectTow(let l), .theftalarmSelectTow(let r)): return l == r
      case (.theftalarmStart(let l), .theftalarmStart(let r)): return l == r
      case (.theftalarmStop(let l), .theftalarmStop(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Temporary backend switch field. Will be removed as soon as all commands are migrated to the VehicleAPI
  /// This field only needs to be set if the command is supported by both API from our backend. If this field is removed
  /// don't forget to set the field 36 to reserved.
  enum Backend: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// default value
    case vva // = 0
    case vehicleApi // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .vva
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .vva
      case 1: self = .vehicleApi
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .vva: return 0
      case .vehicleApi: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Proto_CommandRequest.Backend: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_CommandRequest.Backend] = [
    .vva,
    .vehicleApi,
  ]
}

#endif  // swift(>=4.2)

struct Proto_AuxheatStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AuxheatStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_AuxheatConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeSelection: Proto_AuxheatConfigure.Selection = .noSelection

  /// Minutes from midnight.
  var time1: Int32 = 0

  /// Minutes from midnight.
  var time2: Int32 = 0

  /// Minutes from midnight.
  var time3: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Selection: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case noSelection // = 0
    case time1 // = 1
    case time2 // = 2
    case time3 // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .noSelection
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noSelection
      case 1: self = .time1
      case 2: self = .time2
      case 3: self = .time3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .noSelection: return 0
      case .time1: return 1
      case .time2: return 2
      case .time3: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_AuxheatConfigure.Selection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_AuxheatConfigure.Selection] = [
    .noSelection,
    .time1,
    .time2,
    .time3,
  ]
}

#endif  // swift(>=4.2)

struct Proto_DoorsLock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// doors / flaps to unlock (only supported by TCU type RAMSES)
  /// leave empty to target all doors
  var doors: [Proto_Door] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_DoorsUnlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  /// doors / flaps to unlock (only supported by TCU type RAMSES)
  /// leave empty to target all doors
  var doors: [Proto_Door] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_EngineStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_EngineStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofOpen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SunroofLift {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WindowsOpen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_WindowsClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SpeedalertStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var threshold: Int32 = 0

  var alertEndTime: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SpeedalertStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ZEVPreconditioningStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var departureTime: Int32 = 0

  var type: Proto_ZEVPreconditioningType = .unknownZevPreconditioningCommandType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ZEVPreconditioningStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Proto_ZEVPreconditioningType = .unknownZevPreconditioningCommandType

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configure preconditioning
struct Proto_ZEVPreconditioningConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var departureTimeMode: Proto_ZEVPreconditioningConfigure.DepartureTimeMode = .disabled

  var departureTime: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DepartureTimeMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case disabled // = 0
    case singleDeparture // = 1
    case weeklyDeparture // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .disabled
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .disabled
      case 1: self = .singleDeparture
      case 2: self = .weeklyDeparture
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .disabled: return 0
      case .singleDeparture: return 1
      case .weeklyDeparture: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_ZEVPreconditioningConfigure.DepartureTimeMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ZEVPreconditioningConfigure.DepartureTimeMode] = [
    .disabled,
    .singleDeparture,
    .weeklyDeparture,
  ]
}

#endif  // swift(>=4.2)

/// Configure which seats should be preconditioned.
/// Currently, the only available options are to precondition all seats or only the front-left seat
struct Proto_ZEVPreconditioningConfigureSeats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frontLeft: Bool = false

  var frontRight: Bool = false

  var rearLeft: Bool = false

  var rearRight: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configure the charge program
struct Proto_BatteryChargeProgramConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeProgram: Proto_BatteryChargeProgramConfigure.ChargeProgram = .default

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChargeProgram: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case instant // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .instant
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .instant: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_BatteryChargeProgramConfigure.ChargeProgram: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_BatteryChargeProgramConfigure.ChargeProgram] = [
    .default,
    .instant,
  ]
}

#endif  // swift(>=4.2)

/// Configure the maximum value for the state of charge of the HV battery
struct Proto_BatteryMaxSocConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Values need to be between 50 and 100 and divisible by ten
  var maxSoc: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Select the given charge program and enables the consumer to configure it.
/// Not yet usable, but will be deployed in the beginning of July 2019 on ece-int
struct Proto_ChargeProgramConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeProgram: Proto_ChargeProgramConfigure.ChargeProgram = .defaultChargeprogram

  /// Values need to be between 50 and 100 and divisible by ten
  var maxSoc: Int32 = 0

  /// unlock the plug after charging is finished
  var autoUnlock: Bool = false

  /// automatically switch between home and work program, based on the location of the car
  var locationBasedCharging: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ChargeProgram: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case defaultChargeprogram // = 0
    case instantChargeprogram // = 1
    case homeChargeprogram // = 2
    case workChargeprogram // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .defaultChargeprogram
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .defaultChargeprogram
      case 1: self = .instantChargeprogram
      case 2: self = .homeChargeprogram
      case 3: self = .workChargeprogram
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .defaultChargeprogram: return 0
      case .instantChargeprogram: return 1
      case .homeChargeprogram: return 2
      case .workChargeprogram: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_ChargeProgramConfigure.ChargeProgram: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_ChargeProgramConfigure.ChargeProgram] = [
    .defaultChargeprogram,
    .instantChargeprogram,
    .homeChargeprogram,
    .workChargeprogram,
  ]
}

#endif  // swift(>=4.2)

/// Provide functionality to initiate a charge optimization configuration
struct Proto_ChargeOptConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var weekdayTariff: [Proto_ChargeOptConfigure.Tariff] = []

  var weekendTariff: [Proto_ChargeOptConfigure.Tariff] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Tariff {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rate: Proto_ChargeOptConfigure.Tariff.Rate = .invalidPrice

    /// Time in seconds after 00:00
    var time: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Rate: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case invalidPrice // = 0
      case lowPrice // = 33
      case normalPrice // = 44
      case highPrice // = 66
      case UNRECOGNIZED(Int)

      init() {
        self = .invalidPrice
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .invalidPrice
        case 33: self = .lowPrice
        case 44: self = .normalPrice
        case 66: self = .highPrice
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .invalidPrice: return 0
        case .lowPrice: return 33
        case .normalPrice: return 44
        case .highPrice: return 66
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

/// Provide the functionality to start the charge optimization function in the vehicle
struct Proto_ChargeOptStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to stop the charge optimization function in the vehicle
struct Proto_ChargeOptStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Set the temperature points of the vehicle
struct Proto_TemperatureConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var temperaturePoints: [Proto_TemperatureConfigure.TemperaturePoint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TemperaturePoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var zone: Proto_TemperatureConfigure.TemperaturePoint.Zone = .unknown

    var temperature: Int32 = 0

    var temperatureInCelsius: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Zone: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// the lowercase versions are for json parsing purposes only. The upper case version should be the preferred
      /// enum values to be used in code.
      /// These definitions need to come before upper case versions
      case unknown // = 0
      case frontLeft // = 1
      case frontRight // = 2
      case frontCenter // = 3
      case rearLeft // = 4
      case rearRight // = 5
      case rearCenter // = 6
      case rear2Left // = 7
      case rear2Right // = 8

      /// PLEASE BE AWARE OF THE FOLLOWING BEFORE ADDING NEW ZONES:
      /// Currently there is a bug in vehicle API, that we need to send the zones in the correct order. Otherwise the request will be rejected.
      /// The order needs to be like the following:
      /// Front before rear before rear2
      /// Left before right - There is no center zone if there are left and right zones in this row
      /// As this is already the order like specified here, this needs to be considered on adding new zones.
      case rear2Center // = 9
      static let unknownZone = unknown
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .frontLeft
        case 2: self = .frontRight
        case 3: self = .frontCenter
        case 4: self = .rearLeft
        case 5: self = .rearRight
        case 6: self = .rearCenter
        case 7: self = .rear2Left
        case 8: self = .rear2Right
        case 9: self = .rear2Center
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .frontLeft: return 1
        case .frontRight: return 2
        case .frontCenter: return 3
        case .rearLeft: return 4
        case .rearRight: return 5
        case .rearCenter: return 6
        case .rear2Left: return 7
        case .rear2Right: return 8
        case .rear2Center: return 9
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

/// Set the weekprofile for the weekly departure time settings
struct Proto_WeekProfileConfigure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var weeklySetHu: [Proto_WeekProfileConfigure.WeeklySetHU] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct WeeklySetHU {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var day: Proto_WeekProfileConfigure.WeeklySetHU.Day = .monday

    /// Time in minutes after 00:00
    var time: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Day: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case monday // = 0
      case tuesday // = 1
      case wednesday // = 2
      case thursday // = 3
      case friday // = 4
      case saturday // = 5
      case sunday // = 6
      case UNRECOGNIZED(Int)

      init() {
        self = .monday
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .monday
        case 1: self = .tuesday
        case 2: self = .wednesday
        case 3: self = .thursday
        case 4: self = .friday
        case 5: self = .saturday
        case 6: self = .sunday
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .monday: return 0
        case .tuesday: return 1
        case .wednesday: return 2
        case .thursday: return 3
        case .friday: return 4
        case .saturday: return 5
        case .sunday: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

/// Invoke the Remote Vehicle Finder for signalling the vehicles position with lights, horn or panic alarm.
struct Proto_SigPosStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value needs to be between 0 and 30. The default is 0.
  /// Only allowed for RAMSES
  var hornRepeat: Int32 = 0

  var hornType: Proto_SigPosStart.HornType = .hornOff

  var lightType: Proto_SigPosStart.LightType = .lightOff

  /// Value needs to be between 0 and 10. It indicates how long the light should be switched on.
  var sigposDuration: Int32 = 0

  var sigposType: Proto_SigPosStart.SigposType = .lightOnly

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Only allowed for RAMSES
  enum HornType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case hornOff // = 0
    case hornLowVolume // = 1
    case hornHighVolume // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .hornOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .hornOff
      case 1: self = .hornLowVolume
      case 2: self = .hornHighVolume
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .hornOff: return 0
      case .hornLowVolume: return 1
      case .hornHighVolume: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Only allowed for RAMSES
  enum LightType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case lightOff // = 0
    case dippedHeadLight // = 1
    case warningLight // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .lightOff
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lightOff
      case 1: self = .dippedHeadLight
      case 2: self = .warningLight
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .lightOff: return 0
      case .dippedHeadLight: return 1
      case .warningLight: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum SigposType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case lightOnly // = 0

    /// Only allowed for RAMSES
    case hornOnly // = 1

    /// Only allowed for RAMSES
    case lightAndHorn // = 2

    /// Only allowed for HERMES
    case panicAlarm // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .lightOnly
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lightOnly
      case 1: self = .hornOnly
      case 2: self = .lightAndHorn
      case 3: self = .panicAlarm
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .lightOnly: return 0
      case .hornOnly: return 1
      case .lightAndHorn: return 2
      case .panicAlarm: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_SigPosStart.HornType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_SigPosStart.HornType] = [
    .hornOff,
    .hornLowVolume,
    .hornHighVolume,
  ]
}

extension Proto_SigPosStart.LightType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_SigPosStart.LightType] = [
    .lightOff,
    .dippedHeadLight,
    .warningLight,
  ]
}

extension Proto_SigPosStart.SigposType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Proto_SigPosStart.SigposType] = [
    .lightOnly,
    .hornOnly,
    .lightAndHorn,
    .panicAlarm,
  ]
}

#endif  // swift(>=4.2)

/// Confirm the detected parking bump
struct Proto_TheftalarmConfirmDamagedetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deselect the parking damage detection sensor
struct Proto_TheftalarmDeselectDamagedetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deselect the interior protection sensor
struct Proto_TheftalarmDeselectInterior {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deselect the tow protection sensor
struct Proto_TheftalarmDeselectTow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to select the parking damage detection sensor
struct Proto_TheftalarmSelectDamagedetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to select the interior protection sensor
struct Proto_TheftalarmSelectInterior {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to select the tow protection sensor
struct Proto_TheftalarmSelectTow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to trigger an alarm that lasts for "alarm_duration" seconds
struct Proto_TheftalarmStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify how many seconds the alarm should be switched on
  var alarmDurationInSeconds: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Provide the functionality to deactivate an active/ongoing alarm
struct Proto_TheftalarmStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Door: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "unknown_door", aliases: ["UNKNOWN_DOOR"]),
    1: .aliased(proto: "frontleft", aliases: ["FRONT_LEFT"]),
    2: .aliased(proto: "frontright", aliases: ["FRONT_RIGHT"]),
    3: .aliased(proto: "rearleft", aliases: ["REAR_LEFT"]),
    4: .aliased(proto: "rearright", aliases: ["REAR_RIGHT"]),
    5: .aliased(proto: "trunk", aliases: ["TRUNK"]),
    6: .aliased(proto: "fuelflap", aliases: ["FUEL_FLAP"]),
    7: .aliased(proto: "chargeflap", aliases: ["CHARGE_FLAP"]),
    8: .aliased(proto: "chargecoupler", aliases: ["CHARGE_COUPLER"]),
  ]
}

extension Proto_ZEVPreconditioningType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "unknown_zev_preconditioning_command_type", aliases: ["UNKNOWN_ZEV_PRECONDITIONING_COMMAND_TYPE"]),
    1: .aliased(proto: "immediate", aliases: ["IMMEDIATE"]),
    2: .aliased(proto: "departure", aliases: ["DEPARTURE"]),
    3: .aliased(proto: "now", aliases: ["NOW"]),
    4: .aliased(proto: "departureWeekly", aliases: ["DEPARTURE_WEEKLY"]),
  ]
}

extension Proto_CommandStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "process_id"),
    7: .standard(proto: "request_id"),
    6: .same(proto: "timestamp"),
    25: .standard(proto: "timestamp_in_ms"),
    4: .same(proto: "errors"),
    13: .standard(proto: "blocking_time_seconds"),
    14: .standard(proto: "pin_attempts"),
    9: .standard(proto: "auxheat_start"),
    10: .standard(proto: "auxheat_stop"),
    28: .standard(proto: "auxheat_configure"),
    11: .standard(proto: "doors_lock"),
    12: .standard(proto: "doors_unlock"),
    15: .standard(proto: "sunroof_open"),
    16: .standard(proto: "sunroof_close"),
    17: .standard(proto: "sunroof_lift"),
    18: .standard(proto: "windows_open"),
    19: .standard(proto: "windows_close"),
    26: .standard(proto: "engine_start"),
    27: .standard(proto: "engine_stop"),
    2: .same(proto: "state"),
    3: .same(proto: "condition"),
  ]

  fileprivate class _StorageClass {
    var _processID: Int64 = 0
    var _requestID: String = String()
    var _timestamp: Int64 = 0
    var _timestampInMs: Int64 = 0
    var _errors: [Proto_CommandStatus.AcpError] = []
    var _blockingTimeSeconds: Int64 = 0
    var _pinAttempts: Int32 = 0
    var _type: Proto_CommandStatus.OneOf_Type?
    var _state: Proto_CommandStatus.State = .unkownStateType
    var _condition: Proto_CommandStatus.Condition = .unkownConditionType

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _processID = source._processID
      _requestID = source._requestID
      _timestamp = source._timestamp
      _timestampInMs = source._timestampInMs
      _errors = source._errors
      _blockingTimeSeconds = source._blockingTimeSeconds
      _pinAttempts = source._pinAttempts
      _type = source._type
      _state = source._state
      _condition = source._condition
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularEnumField(value: &_storage._state)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._condition)
        case 4: try decoder.decodeRepeatedEnumField(value: &_storage._errors)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._processID)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._timestamp)
        case 7: try decoder.decodeSingularStringField(value: &_storage._requestID)
        case 9:
          var v: Proto_AuxheatStart?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .auxheatStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .auxheatStart(v)}
        case 10:
          var v: Proto_AuxheatStop?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .auxheatStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .auxheatStop(v)}
        case 11:
          var v: Proto_DoorsLock?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .doorsLock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .doorsLock(v)}
        case 12:
          var v: Proto_DoorsUnlock?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .doorsUnlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .doorsUnlock(v)}
        case 13: try decoder.decodeSingularInt64Field(value: &_storage._blockingTimeSeconds)
        case 14: try decoder.decodeSingularInt32Field(value: &_storage._pinAttempts)
        case 15:
          var v: Proto_SunroofOpen?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .sunroofOpen(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .sunroofOpen(v)}
        case 16:
          var v: Proto_SunroofClose?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .sunroofClose(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .sunroofClose(v)}
        case 17:
          var v: Proto_SunroofLift?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .sunroofLift(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .sunroofLift(v)}
        case 18:
          var v: Proto_WindowsOpen?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .windowsOpen(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .windowsOpen(v)}
        case 19:
          var v: Proto_WindowsClose?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .windowsClose(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .windowsClose(v)}
        case 25: try decoder.decodeSingularInt64Field(value: &_storage._timestampInMs)
        case 26:
          var v: Proto_EngineStart?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .engineStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .engineStart(v)}
        case 27:
          var v: Proto_EngineStop?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .engineStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .engineStop(v)}
        case 28:
          var v: Proto_AuxheatConfigure?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .auxheatConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .auxheatConfigure(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._state != .unkownStateType {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 2)
      }
      if _storage._condition != .unkownConditionType {
        try visitor.visitSingularEnumField(value: _storage._condition, fieldNumber: 3)
      }
      if !_storage._errors.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._errors, fieldNumber: 4)
      }
      if _storage._processID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._processID, fieldNumber: 5)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 6)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 7)
      }
      switch _storage._type {
      case .auxheatStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .auxheatStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .doorsLock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .doorsUnlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case nil: break
      default: break
      }
      if _storage._blockingTimeSeconds != 0 {
        try visitor.visitSingularInt64Field(value: _storage._blockingTimeSeconds, fieldNumber: 13)
      }
      if _storage._pinAttempts != 0 {
        try visitor.visitSingularInt32Field(value: _storage._pinAttempts, fieldNumber: 14)
      }
      switch _storage._type {
      case .sunroofOpen(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .sunroofClose(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .sunroofLift(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .windowsOpen(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .windowsClose(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case nil: break
      default: break
      }
      if _storage._timestampInMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestampInMs, fieldNumber: 25)
      }
      switch _storage._type {
      case .engineStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .engineStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case .auxheatConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      case nil: break
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CommandStatus, rhs: Proto_CommandStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._processID != rhs_storage._processID {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._timestampInMs != rhs_storage._timestampInMs {return false}
        if _storage._errors != rhs_storage._errors {return false}
        if _storage._blockingTimeSeconds != rhs_storage._blockingTimeSeconds {return false}
        if _storage._pinAttempts != rhs_storage._pinAttempts {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._condition != rhs_storage._condition {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CommandStatus.AcpError: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ACP_ERROR"),
    1: .same(proto: "VALUE_OUT_OF_RANGE"),
    2: .same(proto: "WRONG_DATA_TYPE"),
    3: .same(proto: "VALUE_OVERFLOW"),
    4: .same(proto: "INCOMPLETE_VALUES"),
    5: .same(proto: "SYNTAX_ERROR"),
    6: .same(proto: "NULL_INF_VALUES"),
    7: .same(proto: "LOCK_FAILED"),
    8: .same(proto: "FAILED_DUE_TO_DOOR_IS_OPEN"),
    9: .same(proto: "FAILED_DUE_TO_IGNITION_IS_ON"),
    10: .same(proto: "LOCK_REQUEST_NOT_AUTHORIZED"),
    11: .same(proto: "UNLOCK_FAILED"),
    12: .same(proto: "FAILED_DUE_TO_TIMEOUT"),
    13: .same(proto: "FAILED_DUE_TO_INVALID_SMS_TIME"),
    14: .same(proto: "FAILED_BECAUSE_VEHICLE_IS_IN_MOTION"),
    15: .same(proto: "FAILED_DUE_TO_IGNITION_TRANSITION"),
    16: .same(proto: "UNLOCK_REQUEST_NOT_AUTHORIZED"),
    17: .same(proto: "DOOR_IS_OPEN_AFTER_UNLOCK_COMMAND"),
    18: .same(proto: "PROCESSING_FAILED"),
    19: .same(proto: "SERVICE_NOT_AUTHORIZED"),
    20: .same(proto: "REMOTE_WINDOW_ROOF_COMMAND_FAILED"),
    21: .same(proto: "REMOTE_WINDOW_ROOF_COMMAND_FAILED_VEHICLE_STATE_IN_IGN"),
    22: .same(proto: "REMOTE_WINDOW_ROOF_COMMAND_FAILED_WINDOW_NOT_NORMED"),
    23: .same(proto: "PIN_INVALID"),
    24: .same(proto: "CIAM_ID_BLOCKED"),
    25: .same(proto: "REMOTE_VTA_FAILED"),
    26: .same(proto: "REMOTE_VTA_SERVICE_NOT_AUTHORIZED"),
    27: .same(proto: "RS_ABORTED_DOORS_NOT_LOCKED"),
    28: .same(proto: "RS_ABORTED_DOORS_OPEN"),
    29: .same(proto: "RS_ABORTED_HOOD_OPEN"),
    30: .same(proto: "RS_ABORTED_ALARM_ACTIVE"),
    31: .same(proto: "RS_ABORTED_FUEL_LOW"),
    32: .same(proto: "RS_ABORTED_GAS_PEDAL_PRESSED"),
    33: .same(proto: "RS_ABORTED_NOT_ALLOWED_BY_EIS"),
    34: .same(proto: "RS_ABORTED_ENGINE_UNEXPECTED_SHUT_OFF"),
    35: .same(proto: "RS_DENIED_NOT_ALLOWED_BY_EIS"),
    36: .same(proto: "RS_DENIED_VEHICLE_NOT_IN_PARK"),
    37: .same(proto: "RS_DENIED_DOORS_NOT_LOCKED"),
    38: .same(proto: "RS_DENIED_DOORS_OPEN"),
    39: .same(proto: "RS_DENIED_WINDOWS_OPEN"),
    40: .same(proto: "RS_DENIED_HOOD_OPEN"),
    41: .same(proto: "RS_DENIED_ALARM_ACTIVE"),
    42: .same(proto: "RS_DENIED_FUEL_LOW"),
    43: .same(proto: "RS_DENIED_GAS_PEDAL_PRESSED"),
    44: .same(proto: "RS_DENIED_DELAY_NOT_EXPIRED"),
    45: .same(proto: "RS_ABORTED_INVALID_CHALLENGE_RESPONSE"),
    46: .same(proto: "RS_DENIED_NUMBER_OF_REQUESTS_EXPIRED"),
    47: .same(proto: "RS_ABORTED_REQUEST_REFUSED_BY_ENGINE"),
    48: .same(proto: "RS_NO_CAN_ACKNOWLEDGEMENT"),
    49: .same(proto: "RS_DENIED_NOT_AUTHORIZED"),
    50: .same(proto: "RS_ABORTED_CHARGE_CABLE_PLUGGED"),
    51: .same(proto: "RS_FBS_RESP_GENERATION_NOT_POSSIBLE_FOR_VIN"),
    52: .same(proto: "RS_FBS_MAINTENANCE"),
    53: .same(proto: "RS_CALLBACK_TIMEOUT"),
    54: .same(proto: "RS_FBS_GENERAL_ERROR"),
    55: .same(proto: "RS_CURRENTLY_BLOCKED"),
    56: .same(proto: "RS_DENIED_AFTER_CHALLENGE_DOORS_NOT_LOCKED"),
    57: .same(proto: "RS_DENIED_AFTER_CHALLENGE_DOORS_OPEN"),
    58: .same(proto: "RS_DENIED_AFTER_CHALLENGE_HOOD_OPEN"),
    59: .same(proto: "RS_DENIED_AFTER_CHALLENGE_ALARM_ACTIVE"),
    60: .same(proto: "RS_DENIED_AFTER_CHALLENGE_NOT_ALLOWED_BY_EIS"),
    61: .same(proto: "NO_APPTWIN_CONNECTED"),
    62: .same(proto: "REMOTE_WINDOW_ROOF_COMMAND_FAILED_SERVICE_NOT_AUTHORIZED_IN_TCU"),
    63: .same(proto: "ENERGY_LEVEL_IN_BATTERY_IS_TOO_LOW"),
    64: .same(proto: "VVA_RESPONDED_SERVICE_NOT_ACTIVATED"),
    65: .same(proto: "CONFIGURATION_PROCESSING_FAILED"),
    66: .same(proto: "PROCESSING_FAILED_CUSTOMER_MAX_SOC_BELOW_VEHICLE_THRESHOLD"),
    67: .same(proto: "CONFIGURATION_NOT_AUTHORIZED"),
    68: .same(proto: "ZEV_WEEK_DEPT_SET_PROCESSING_FAILED"),
    69: .same(proto: "ZEV_WEEK_DEPT_SET_NOT_AUTHORIZED"),
    70: .same(proto: "ZEV_WEEK_DEPT_SET_PROCESSING_OVERWRITTEN"),
    71: .same(proto: "ZEV_WEEK_DEPT_SET_PROCESSING_NOT_POSSIBLE_DUE_TO_INSTANT_CHARGING"),
    72: .same(proto: "FASTPATH_TIMEOUT"),
    73: .same(proto: "ZEV_CHARGE_PROGRAM_NOT_SUPPORTED_BY_VEHICLE"),
    74: .same(proto: "SIGPOS_FAILED"),
    75: .same(proto: "SIGPOS_VEHICLE_IN_IGNITION"),
    76: .same(proto: "SIGPOS_NOT_AUTHORIZED"),
    77: .same(proto: "REMOTE_VTA_IGNITION_NOT_LOCKED"),
    78: .same(proto: "REMOTE_VTA_VVR_VALUE_NOT_SET"),
    79: .same(proto: "REMOTE_VTA_VVR_NOT_ALLOWED"),
  ]
}

extension Proto_CommandStatus.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKOWN_STATE_TYPE"),
    1: .same(proto: "CREATED"),
    2: .same(proto: "ENQUEUED"),
    3: .same(proto: "PROCESSING"),
    4: .same(proto: "SUSPENDED"),
    5: .same(proto: "FINISHED"),
  ]
}

extension Proto_CommandStatus.Condition: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKOWN_CONDITION_TYPE"),
    1: .same(proto: "NONE"),
    2: .same(proto: "ACCEPTED"),
    3: .same(proto: "REJECTED"),
    4: .same(proto: "TERMINATE"),
    5: .same(proto: "SUCCESS"),
    6: .same(proto: "FAILED"),
    7: .same(proto: "OVERWRITTEN"),
    8: .same(proto: "TIMEOUT"),
    9: .same(proto: "DUPLICATE"),
  ]
}

extension Proto_AcknowledgeCommandStatusUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeCommandStatusUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.sequenceNumber)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeCommandStatusUpdateRequest, rhs: Proto_AcknowledgeCommandStatusUpdateRequest) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CommandStatusUpdatesByVIN: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandStatusUpdatesByVIN"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto_CommandStatusUpdate>.self, value: &self.updates)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Proto_CommandStatusUpdate>.self, value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CommandStatusUpdatesByVIN, rhs: Proto_CommandStatusUpdatesByVIN) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CommandStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandStatusUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .same(proto: "vin"),
    3: .standard(proto: "emit_timestamp"),
    7: .standard(proto: "emit_timestamp_in_ms"),
    6: .same(proto: "updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.sequenceNumber)
      case 2: try decoder.decodeSingularStringField(value: &self.vin)
      case 3: try decoder.decodeSingularInt64Field(value: &self.emitTimestamp)
      case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Proto_CommandStatus>.self, value: &self.updates)
      case 7: try decoder.decodeSingularInt64Field(value: &self.emitTimestampInMs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    if !self.vin.isEmpty {
      try visitor.visitSingularStringField(value: self.vin, fieldNumber: 2)
    }
    if self.emitTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestamp, fieldNumber: 3)
    }
    if !self.updates.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Proto_CommandStatus>.self, value: self.updates, fieldNumber: 6)
    }
    if self.emitTimestampInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.emitTimestampInMs, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CommandStatusUpdate, rhs: Proto_CommandStatusUpdate) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.vin != rhs.vin {return false}
    if lhs.emitTimestamp != rhs.emitTimestamp {return false}
    if lhs.emitTimestampInMs != rhs.emitTimestampInMs {return false}
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AcknowledgeCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcknowledgeCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.requestID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AcknowledgeCommandRequest, rhs: Proto_AcknowledgeCommandRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vin"),
    7: .standard(proto: "request_id"),
    36: .same(proto: "backend"),
    2: .standard(proto: "auxheat_start"),
    3: .standard(proto: "auxheat_stop"),
    4: .standard(proto: "auxheat_configure"),
    5: .standard(proto: "doors_lock"),
    6: .standard(proto: "doors_unlock"),
    9: .standard(proto: "sunroof_open"),
    10: .standard(proto: "sunroof_close"),
    11: .standard(proto: "sunroof_lift"),
    12: .standard(proto: "windows_open"),
    13: .standard(proto: "windows_close"),
    19: .standard(proto: "engine_start"),
    20: .standard(proto: "engine_stop"),
    21: .standard(proto: "zev_preconditioning_start"),
    22: .standard(proto: "zev_preconditioning_stop"),
    25: .standard(proto: "zev_precondition_configure"),
    26: .standard(proto: "zev_precondition_configure_seats"),
    23: .standard(proto: "speedalert_start"),
    24: .standard(proto: "speedalert_stop"),
    27: .standard(proto: "battery_charge_program"),
    28: .standard(proto: "battery_max_soc"),
    34: .standard(proto: "charge_program_configure"),
    29: .standard(proto: "charge_opt_configure"),
    30: .standard(proto: "charge_opt_start"),
    31: .standard(proto: "charge_opt_stop"),
    32: .standard(proto: "temperature_configure"),
    33: .standard(proto: "week_profile_configure"),
    35: .standard(proto: "sigpos_start"),
    8: .standard(proto: "theftalarm_confirm_damagedetection"),
    14: .standard(proto: "theftalarm_deselect_damagedetection"),
    15: .standard(proto: "theftalarm_deselect_interior"),
    16: .standard(proto: "theftalarm_deselect_tow"),
    17: .standard(proto: "theftalarm_select_damagedetection"),
    18: .standard(proto: "theftalarm_select_interior"),
    37: .standard(proto: "theftalarm_select_tow"),
    38: .standard(proto: "theftalarm_start"),
    39: .standard(proto: "theftalarm_stop"),
  ]

  fileprivate class _StorageClass {
    var _vin: String = String()
    var _requestID: String = String()
    var _backend: Proto_CommandRequest.Backend = .vva
    var _command: Proto_CommandRequest.OneOf_Command?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _vin = source._vin
      _requestID = source._requestID
      _backend = source._backend
      _command = source._command
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._vin)
        case 2:
          var v: Proto_AuxheatStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .auxheatStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .auxheatStart(v)}
        case 3:
          var v: Proto_AuxheatStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .auxheatStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .auxheatStop(v)}
        case 4:
          var v: Proto_AuxheatConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .auxheatConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .auxheatConfigure(v)}
        case 5:
          var v: Proto_DoorsLock?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .doorsLock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .doorsLock(v)}
        case 6:
          var v: Proto_DoorsUnlock?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .doorsUnlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .doorsUnlock(v)}
        case 7: try decoder.decodeSingularStringField(value: &_storage._requestID)
        case 8:
          var v: Proto_TheftalarmConfirmDamagedetection?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmConfirmDamagedetection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmConfirmDamagedetection(v)}
        case 9:
          var v: Proto_SunroofOpen?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .sunroofOpen(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .sunroofOpen(v)}
        case 10:
          var v: Proto_SunroofClose?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .sunroofClose(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .sunroofClose(v)}
        case 11:
          var v: Proto_SunroofLift?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .sunroofLift(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .sunroofLift(v)}
        case 12:
          var v: Proto_WindowsOpen?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .windowsOpen(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .windowsOpen(v)}
        case 13:
          var v: Proto_WindowsClose?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .windowsClose(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .windowsClose(v)}
        case 14:
          var v: Proto_TheftalarmDeselectDamagedetection?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmDeselectDamagedetection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmDeselectDamagedetection(v)}
        case 15:
          var v: Proto_TheftalarmDeselectInterior?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmDeselectInterior(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmDeselectInterior(v)}
        case 16:
          var v: Proto_TheftalarmDeselectTow?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmDeselectTow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmDeselectTow(v)}
        case 17:
          var v: Proto_TheftalarmSelectDamagedetection?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmSelectDamagedetection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmSelectDamagedetection(v)}
        case 18:
          var v: Proto_TheftalarmSelectInterior?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmSelectInterior(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmSelectInterior(v)}
        case 19:
          var v: Proto_EngineStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .engineStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .engineStart(v)}
        case 20:
          var v: Proto_EngineStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .engineStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .engineStop(v)}
        case 21:
          var v: Proto_ZEVPreconditioningStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .zevPreconditioningStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .zevPreconditioningStart(v)}
        case 22:
          var v: Proto_ZEVPreconditioningStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .zevPreconditioningStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .zevPreconditioningStop(v)}
        case 23:
          var v: Proto_SpeedalertStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .speedalertStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .speedalertStart(v)}
        case 24:
          var v: Proto_SpeedalertStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .speedalertStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .speedalertStop(v)}
        case 25:
          var v: Proto_ZEVPreconditioningConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .zevPreconditionConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .zevPreconditionConfigure(v)}
        case 26:
          var v: Proto_ZEVPreconditioningConfigureSeats?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .zevPreconditionConfigureSeats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .zevPreconditionConfigureSeats(v)}
        case 27:
          var v: Proto_BatteryChargeProgramConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .batteryChargeProgram(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .batteryChargeProgram(v)}
        case 28:
          var v: Proto_BatteryMaxSocConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .batteryMaxSoc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .batteryMaxSoc(v)}
        case 29:
          var v: Proto_ChargeOptConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeOptConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeOptConfigure(v)}
        case 30:
          var v: Proto_ChargeOptStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeOptStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeOptStart(v)}
        case 31:
          var v: Proto_ChargeOptStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeOptStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeOptStop(v)}
        case 32:
          var v: Proto_TemperatureConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .temperatureConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .temperatureConfigure(v)}
        case 33:
          var v: Proto_WeekProfileConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .weekProfileConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .weekProfileConfigure(v)}
        case 34:
          var v: Proto_ChargeProgramConfigure?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .chargeProgramConfigure(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .chargeProgramConfigure(v)}
        case 35:
          var v: Proto_SigPosStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .sigposStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .sigposStart(v)}
        case 36: try decoder.decodeSingularEnumField(value: &_storage._backend)
        case 37:
          var v: Proto_TheftalarmSelectTow?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmSelectTow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmSelectTow(v)}
        case 38:
          var v: Proto_TheftalarmStart?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmStart(v)}
        case 39:
          var v: Proto_TheftalarmStop?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .theftalarmStop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .theftalarmStop(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._vin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vin, fieldNumber: 1)
      }
      switch _storage._command {
      case .auxheatStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .auxheatStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .auxheatConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .doorsLock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .doorsUnlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      default: break
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 7)
      }
      switch _storage._command {
      case .theftalarmConfirmDamagedetection(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .sunroofOpen(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .sunroofClose(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .sunroofLift(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .windowsOpen(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .windowsClose(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .theftalarmDeselectDamagedetection(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .theftalarmDeselectInterior(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .theftalarmDeselectTow(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .theftalarmSelectDamagedetection(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .theftalarmSelectInterior(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .engineStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .engineStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .zevPreconditioningStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .zevPreconditioningStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .speedalertStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .speedalertStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .zevPreconditionConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .zevPreconditionConfigureSeats(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .batteryChargeProgram(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case .batteryMaxSoc(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      case .chargeOptConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      case .chargeOptStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case .chargeOptStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      case .temperatureConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      case .weekProfileConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      case .chargeProgramConfigure(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      case .sigposStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      case nil: break
      default: break
      }
      if _storage._backend != .vva {
        try visitor.visitSingularEnumField(value: _storage._backend, fieldNumber: 36)
      }
      switch _storage._command {
      case .theftalarmSelectTow(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      case .theftalarmStart(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      case .theftalarmStop(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      case nil: break
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CommandRequest, rhs: Proto_CommandRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._vin != rhs_storage._vin {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._backend != rhs_storage._backend {return false}
        if _storage._command != rhs_storage._command {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CommandRequest.Backend: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VVA"),
    1: .same(proto: "VehicleAPI"),
  ]
}

extension Proto_AuxheatStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuxheatStart"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuxheatStart, rhs: Proto_AuxheatStart) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuxheatStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuxheatStop, rhs: Proto_AuxheatStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuxheatConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_selection"),
    2: .standard(proto: "time_1"),
    3: .standard(proto: "time_2"),
    4: .standard(proto: "time_3"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.timeSelection)
      case 2: try decoder.decodeSingularInt32Field(value: &self.time1)
      case 3: try decoder.decodeSingularInt32Field(value: &self.time2)
      case 4: try decoder.decodeSingularInt32Field(value: &self.time3)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeSelection != .noSelection {
      try visitor.visitSingularEnumField(value: self.timeSelection, fieldNumber: 1)
    }
    if self.time1 != 0 {
      try visitor.visitSingularInt32Field(value: self.time1, fieldNumber: 2)
    }
    if self.time2 != 0 {
      try visitor.visitSingularInt32Field(value: self.time2, fieldNumber: 3)
    }
    if self.time3 != 0 {
      try visitor.visitSingularInt32Field(value: self.time3, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuxheatConfigure, rhs: Proto_AuxheatConfigure) -> Bool {
    if lhs.timeSelection != rhs.timeSelection {return false}
    if lhs.time1 != rhs.time1 {return false}
    if lhs.time2 != rhs.time2 {return false}
    if lhs.time3 != rhs.time3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuxheatConfigure.Selection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_SELECTION"),
    1: .same(proto: "TIME_1"),
    2: .same(proto: "TIME_2"),
    3: .same(proto: "TIME_3"),
  ]
}

extension Proto_DoorsLock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoorsLock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "doors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedEnumField(value: &self.doors)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.doors.isEmpty {
      try visitor.visitPackedEnumField(value: self.doors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DoorsLock, rhs: Proto_DoorsLock) -> Bool {
    if lhs.doors != rhs.doors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DoorsUnlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoorsUnlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .same(proto: "doors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      case 2: try decoder.decodeRepeatedEnumField(value: &self.doors)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    if !self.doors.isEmpty {
      try visitor.visitPackedEnumField(value: self.doors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DoorsUnlock, rhs: Proto_DoorsUnlock) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.doors != rhs.doors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_EngineStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EngineStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_EngineStart, rhs: Proto_EngineStart) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_EngineStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EngineStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_EngineStop, rhs: Proto_EngineStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofOpen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofOpen, rhs: Proto_SunroofOpen) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofClose"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofClose, rhs: Proto_SunroofClose) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SunroofLift: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SunroofLift"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SunroofLift, rhs: Proto_SunroofLift) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsOpen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsOpen, rhs: Proto_WindowsOpen) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsClose"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsClose, rhs: Proto_WindowsClose) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SpeedalertStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedalertStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .standard(proto: "alert_end_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.threshold)
      case 2: try decoder.decodeSingularInt32Field(value: &self.alertEndTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threshold != 0 {
      try visitor.visitSingularInt32Field(value: self.threshold, fieldNumber: 1)
    }
    if self.alertEndTime != 0 {
      try visitor.visitSingularInt32Field(value: self.alertEndTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SpeedalertStart, rhs: Proto_SpeedalertStart) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs.alertEndTime != rhs.alertEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SpeedalertStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedalertStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SpeedalertStop, rhs: Proto_SpeedalertStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "departure_time", json: "departuretime"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.departureTime)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.departureTime != 0 {
      try visitor.visitSingularInt32Field(value: self.departureTime, fieldNumber: 1)
    }
    if self.type != .unknownZevPreconditioningCommandType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningStart, rhs: Proto_ZEVPreconditioningStart) -> Bool {
    if lhs.departureTime != rhs.departureTime {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningStop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownZevPreconditioningCommandType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningStop, rhs: Proto_ZEVPreconditioningStop) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "departure_time_mode"),
    3: .unique(proto: "departure_time", json: "departuretime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.departureTimeMode)
      case 3: try decoder.decodeSingularInt32Field(value: &self.departureTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.departureTimeMode != .disabled {
      try visitor.visitSingularEnumField(value: self.departureTimeMode, fieldNumber: 1)
    }
    if self.departureTime != 0 {
      try visitor.visitSingularInt32Field(value: self.departureTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningConfigure, rhs: Proto_ZEVPreconditioningConfigure) -> Bool {
    if lhs.departureTimeMode != rhs.departureTimeMode {return false}
    if lhs.departureTime != rhs.departureTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ZEVPreconditioningConfigure.DepartureTimeMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISABLED"),
    1: .same(proto: "SINGLE_DEPARTURE"),
    2: .same(proto: "WEEKLY_DEPARTURE"),
  ]
}

extension Proto_ZEVPreconditioningConfigureSeats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZEVPreconditioningConfigureSeats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "front_left", json: "precondSeatFrontLeft"),
    2: .unique(proto: "front_right", json: "precondSeatFrontRight"),
    3: .unique(proto: "rear_left", json: "precondSeatRearLeft"),
    4: .unique(proto: "rear_right", json: "precondSeatRearRight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.frontLeft)
      case 2: try decoder.decodeSingularBoolField(value: &self.frontRight)
      case 3: try decoder.decodeSingularBoolField(value: &self.rearLeft)
      case 4: try decoder.decodeSingularBoolField(value: &self.rearRight)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frontLeft != false {
      try visitor.visitSingularBoolField(value: self.frontLeft, fieldNumber: 1)
    }
    if self.frontRight != false {
      try visitor.visitSingularBoolField(value: self.frontRight, fieldNumber: 2)
    }
    if self.rearLeft != false {
      try visitor.visitSingularBoolField(value: self.rearLeft, fieldNumber: 3)
    }
    if self.rearRight != false {
      try visitor.visitSingularBoolField(value: self.rearRight, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ZEVPreconditioningConfigureSeats, rhs: Proto_ZEVPreconditioningConfigureSeats) -> Bool {
    if lhs.frontLeft != rhs.frontLeft {return false}
    if lhs.frontRight != rhs.frontRight {return false}
    if lhs.rearLeft != rhs.rearLeft {return false}
    if lhs.rearRight != rhs.rearRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_BatteryChargeProgramConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryChargeProgramConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "charge_program", json: "chargeprogram"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.chargeProgram)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargeProgram != .default {
      try visitor.visitSingularEnumField(value: self.chargeProgram, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_BatteryChargeProgramConfigure, rhs: Proto_BatteryChargeProgramConfigure) -> Bool {
    if lhs.chargeProgram != rhs.chargeProgram {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_BatteryChargeProgramConfigure.ChargeProgram: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "INSTANT"),
  ]
}

extension Proto_BatteryMaxSocConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryMaxSocConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "max_soc", json: "maxsoc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.maxSoc)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxSoc != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSoc, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_BatteryMaxSocConfigure, rhs: Proto_BatteryMaxSocConfigure) -> Bool {
    if lhs.maxSoc != rhs.maxSoc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeProgramConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeProgramConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "charge_program", json: "chargeprogram"),
    2: .unique(proto: "max_soc", json: "maxsoc"),
    3: .unique(proto: "auto_unlock", json: "autounlock"),
    4: .unique(proto: "location_based_charging", json: "locationbasedcharging"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.chargeProgram)
      case 2: try decoder.decodeSingularInt32Field(value: &self.maxSoc)
      case 3: try decoder.decodeSingularBoolField(value: &self.autoUnlock)
      case 4: try decoder.decodeSingularBoolField(value: &self.locationBasedCharging)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargeProgram != .defaultChargeprogram {
      try visitor.visitSingularEnumField(value: self.chargeProgram, fieldNumber: 1)
    }
    if self.maxSoc != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSoc, fieldNumber: 2)
    }
    if self.autoUnlock != false {
      try visitor.visitSingularBoolField(value: self.autoUnlock, fieldNumber: 3)
    }
    if self.locationBasedCharging != false {
      try visitor.visitSingularBoolField(value: self.locationBasedCharging, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeProgramConfigure, rhs: Proto_ChargeProgramConfigure) -> Bool {
    if lhs.chargeProgram != rhs.chargeProgram {return false}
    if lhs.maxSoc != rhs.maxSoc {return false}
    if lhs.autoUnlock != rhs.autoUnlock {return false}
    if lhs.locationBasedCharging != rhs.locationBasedCharging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeProgramConfigure.ChargeProgram: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT_CHARGEPROGRAM"),
    1: .same(proto: "INSTANT_CHARGEPROGRAM"),
    2: .same(proto: "HOME_CHARGEPROGRAM"),
    3: .same(proto: "WORK_CHARGEPROGRAM"),
  ]
}

extension Proto_ChargeOptConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOptConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "weekday_tariff", json: "weekdaytariff"),
    2: .unique(proto: "weekend_tariff", json: "weekendtariff"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.weekdayTariff)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.weekendTariff)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weekdayTariff.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weekdayTariff, fieldNumber: 1)
    }
    if !self.weekendTariff.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weekendTariff, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptConfigure, rhs: Proto_ChargeOptConfigure) -> Bool {
    if lhs.weekdayTariff != rhs.weekdayTariff {return false}
    if lhs.weekendTariff != rhs.weekendTariff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptConfigure.Tariff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_ChargeOptConfigure.protoMessageName + ".Tariff"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rate"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.rate)
      case 2: try decoder.decodeSingularInt32Field(value: &self.time)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rate != .invalidPrice {
      try visitor.visitSingularEnumField(value: self.rate, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptConfigure.Tariff, rhs: Proto_ChargeOptConfigure.Tariff) -> Bool {
    if lhs.rate != rhs.rate {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptConfigure.Tariff.Rate: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_PRICE"),
    33: .same(proto: "LOW_PRICE"),
    44: .same(proto: "NORMAL_PRICE"),
    66: .same(proto: "HIGH_PRICE"),
  ]
}

extension Proto_ChargeOptStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOptStart"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptStart, rhs: Proto_ChargeOptStart) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChargeOptStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChargeOptStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChargeOptStop, rhs: Proto_ChargeOptStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperatureConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TemperatureConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "temperature_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.temperaturePoints)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.temperaturePoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.temperaturePoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TemperatureConfigure, rhs: Proto_TemperatureConfigure) -> Bool {
    if lhs.temperaturePoints != rhs.temperaturePoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperatureConfigure.TemperaturePoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_TemperatureConfigure.protoMessageName + ".TemperaturePoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "zone"),
    2: .same(proto: "temperature"),
    3: .unique(proto: "temperature_in_celsius", json: "temp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.zone)
      case 2: try decoder.decodeSingularInt32Field(value: &self.temperature)
      case 3: try decoder.decodeSingularDoubleField(value: &self.temperatureInCelsius)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.zone != .unknown {
      try visitor.visitSingularEnumField(value: self.zone, fieldNumber: 1)
    }
    if self.temperature != 0 {
      try visitor.visitSingularInt32Field(value: self.temperature, fieldNumber: 2)
    }
    if self.temperatureInCelsius != 0 {
      try visitor.visitSingularDoubleField(value: self.temperatureInCelsius, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TemperatureConfigure.TemperaturePoint, rhs: Proto_TemperatureConfigure.TemperaturePoint) -> Bool {
    if lhs.zone != rhs.zone {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.temperatureInCelsius != rhs.temperatureInCelsius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TemperatureConfigure.TemperaturePoint.Zone: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "unknown", aliases: ["UNKNOWN_ZONE"]),
    1: .aliased(proto: "frontLeft", aliases: ["FRONT_LEFT"]),
    2: .aliased(proto: "frontRight", aliases: ["FRONT_RIGHT"]),
    3: .aliased(proto: "frontCenter", aliases: ["FRONT_CENTER"]),
    4: .aliased(proto: "rearLeft", aliases: ["REAR_LEFT"]),
    5: .aliased(proto: "rearRight", aliases: ["REAR_RIGHT"]),
    6: .aliased(proto: "rearCenter", aliases: ["REAR_CENTER"]),
    7: .aliased(proto: "rear2Left", aliases: ["REAR_2_LEFT"]),
    8: .aliased(proto: "rear2Right", aliases: ["REAR_2_RIGHT"]),
    9: .aliased(proto: "rear2Center", aliases: ["REAR_2_CENTER"]),
  ]
}

extension Proto_WeekProfileConfigure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeekProfileConfigure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "weekly_set_hu", json: "weeklySetHU"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.weeklySetHu)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weeklySetHu.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weeklySetHu, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeekProfileConfigure, rhs: Proto_WeekProfileConfigure) -> Bool {
    if lhs.weeklySetHu != rhs.weeklySetHu {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeekProfileConfigure.WeeklySetHU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Proto_WeekProfileConfigure.protoMessageName + ".WeeklySetHU"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "day"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.day)
      case 2: try decoder.decodeSingularInt32Field(value: &self.time)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.day != .monday {
      try visitor.visitSingularEnumField(value: self.day, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt32Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WeekProfileConfigure.WeeklySetHU, rhs: Proto_WeekProfileConfigure.WeeklySetHU) -> Bool {
    if lhs.day != rhs.day {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WeekProfileConfigure.WeeklySetHU.Day: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MONDAY"),
    1: .same(proto: "TUESDAY"),
    2: .same(proto: "WEDNESDAY"),
    3: .same(proto: "THURSDAY"),
    4: .same(proto: "FRIDAY"),
    5: .same(proto: "SATURDAY"),
    6: .same(proto: "SUNDAY"),
  ]
}

extension Proto_SigPosStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SigPosStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "horn_repeat"),
    2: .standard(proto: "horn_type"),
    3: .standard(proto: "light_type"),
    4: .standard(proto: "sigpos_duration"),
    5: .standard(proto: "sigpos_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.hornRepeat)
      case 2: try decoder.decodeSingularEnumField(value: &self.hornType)
      case 3: try decoder.decodeSingularEnumField(value: &self.lightType)
      case 4: try decoder.decodeSingularInt32Field(value: &self.sigposDuration)
      case 5: try decoder.decodeSingularEnumField(value: &self.sigposType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hornRepeat != 0 {
      try visitor.visitSingularInt32Field(value: self.hornRepeat, fieldNumber: 1)
    }
    if self.hornType != .hornOff {
      try visitor.visitSingularEnumField(value: self.hornType, fieldNumber: 2)
    }
    if self.lightType != .lightOff {
      try visitor.visitSingularEnumField(value: self.lightType, fieldNumber: 3)
    }
    if self.sigposDuration != 0 {
      try visitor.visitSingularInt32Field(value: self.sigposDuration, fieldNumber: 4)
    }
    if self.sigposType != .lightOnly {
      try visitor.visitSingularEnumField(value: self.sigposType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SigPosStart, rhs: Proto_SigPosStart) -> Bool {
    if lhs.hornRepeat != rhs.hornRepeat {return false}
    if lhs.hornType != rhs.hornType {return false}
    if lhs.lightType != rhs.lightType {return false}
    if lhs.sigposDuration != rhs.sigposDuration {return false}
    if lhs.sigposType != rhs.sigposType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SigPosStart.HornType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HORN_OFF"),
    1: .same(proto: "HORN_LOW_VOLUME"),
    2: .same(proto: "HORN_HIGH_VOLUME"),
  ]
}

extension Proto_SigPosStart.LightType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIGHT_OFF"),
    1: .same(proto: "DIPPED_HEAD_LIGHT"),
    2: .same(proto: "WARNING_LIGHT"),
  ]
}

extension Proto_SigPosStart.SigposType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIGHT_ONLY"),
    1: .same(proto: "HORN_ONLY"),
    2: .same(proto: "LIGHT_AND_HORN"),
    3: .same(proto: "PANIC_ALARM"),
  ]
}

extension Proto_TheftalarmConfirmDamagedetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmConfirmDamagedetection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmConfirmDamagedetection, rhs: Proto_TheftalarmConfirmDamagedetection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmDeselectDamagedetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmDeselectDamagedetection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmDeselectDamagedetection, rhs: Proto_TheftalarmDeselectDamagedetection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmDeselectInterior: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmDeselectInterior"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmDeselectInterior, rhs: Proto_TheftalarmDeselectInterior) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmDeselectTow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmDeselectTow"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmDeselectTow, rhs: Proto_TheftalarmDeselectTow) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmSelectDamagedetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmSelectDamagedetection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmSelectDamagedetection, rhs: Proto_TheftalarmSelectDamagedetection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmSelectInterior: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmSelectInterior"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmSelectInterior, rhs: Proto_TheftalarmSelectInterior) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmSelectTow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmSelectTow"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmSelectTow, rhs: Proto_TheftalarmSelectTow) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "alarm_duration_in_seconds", json: "alarmduration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.alarmDurationInSeconds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alarmDurationInSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.alarmDurationInSeconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmStart, rhs: Proto_TheftalarmStart) -> Bool {
    if lhs.alarmDurationInSeconds != rhs.alarmDurationInSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TheftalarmStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TheftalarmStop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TheftalarmStop, rhs: Proto_TheftalarmStop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
